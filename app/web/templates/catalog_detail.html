{% extends "base.html" %}

{% block content %}
  <section class="detail-header">
    <a class="ghost-button" href="/catalog?lang={{ lang }}">{{ t("Back to catalog") }}</a>
    <div class="detail-title">{{ item.title }}</div>
    <div class="detail-markup-type">
      <span class="detail-markup-type-label">{{ "markup_type" | humanize_text }}</span>
      <span class="detail-markup-type-value">{{ item.markup_type | humanize_text }}</span>
    </div>
    <div class="detail-meta">
      <span>{{ t("Updated") }} {{ item.updated_at | msk_datetime }}</span>
      <span>{{ t("Scene ID") }} {{ item.scene_id }}</span>
    </div>
    {% if item.tags %}
      <div class="tag-row">
        {% for tag in item.tags %}
          <span class="tag">{{ tag }}</span>
        {% endfor %}
      </div>
    {% endif %}
  </section>

  <section class="detail-grid">
    <div class="detail-card">
      <h3>{{ t("Block-level diagram") }}</h3>
      <div class="button-row">
        {% if block_graph_enabled %}
          <button class="ghost-button render-graph-button" type="button" id="render-service-graph">
            {{ t("Show graph") }}
          </button>
        {% endif %}
        {% if diagram_excalidraw_enabled %}
          <a class="primary-button" target="_blank" href="{{ excalidraw_open_url }}">{{ t("Open Excalidraw") }}</a>
        {% endif %}
        <a class="ghost-button" href="/api/scenes/{{ item.scene_id }}?format=excalidraw&download=true">
          {{ t("Download .excalidraw") }}
        </a>
        <a
          class="{% if diagram_excalidraw_enabled %}ghost-button unidraw-button{% else %}primary-button{% endif %}"
          href="/api/scenes/{{ item.scene_id }}?format=unidraw&download=true"
        >
          {{ t("Download .unidraw") }}
        </a>
      </div>
      {% if not excalidraw_scene_available %}
        {% if on_demand_enabled %}
          <p class="note">{{ t("Scene will be generated on demand from markup.") }}</p>
        {% else %}
          <p class="note">
            {{ t("Scene file not found in {dir_name}. Run build-all before opening.", dir_name=excalidraw_dir_label) }}
          </p>
        {% endif %}
      {% elif open_mode == "manual" %}
        <p class="note">{{ t("Scene is too large for URL sharing. Use Download + Import.") }}</p>
      {% endif %}
    </div>

    <div class="detail-card">
      <h3>{{ t("Procedure-level diagram") }}</h3>
      <div class="button-row">
        {% if procedure_graph_enabled %}
          <button class="ghost-button render-graph-button" type="button" id="render-procedure-graph">
            {{ t("Show graph") }}
          </button>
        {% endif %}
        {% if diagram_excalidraw_enabled %}
          <a class="primary-button" target="_blank" href="{{ procedure_excalidraw_open_url }}">
            {{ t("Open Excalidraw") }}
          </a>
        {% endif %}
        <a class="ghost-button" href="/api/scenes/{{ item.scene_id }}/procedure-graph?format=excalidraw&download=true">
          {{ t("Download .excalidraw") }}
        </a>
        <a
          class="{% if diagram_excalidraw_enabled %}ghost-button unidraw-button{% else %}primary-button{% endif %}"
          href="/api/scenes/{{ item.scene_id }}/procedure-graph?format=unidraw&download=true"
        >
          {{ t("Download .unidraw") }}
        </a>
      </div>
      {% if not procedure_graph_enabled %}
        <p class="note">{{ t("No procedure graph data available for this service.") }}</p>
      {% elif procedure_open_mode == "manual" %}
        <p class="note">{{ t("Scene is too large for URL sharing. Use Download + Import.") }}</p>
      {% endif %}
    </div>
  </section>

  {% if block_graph_enabled %}
    <div class="service-graph-modal" id="service-graph-modal" hidden>
      <div class="service-graph-backdrop" id="service-graph-backdrop"></div>
      <section
        class="service-graph-sheet"
        role="dialog"
        aria-modal="true"
        aria-label="{{ t("Service block graph") }}"
      >
        <header class="service-graph-toolbar">
          <h3 class="service-graph-title">{{ t("Service block graph") }}</h3>
          <div class="button-row service-graph-actions">
            <button class="ghost-button" type="button" id="service-graph-fit">{{ t("Fit graph") }}</button>
            <button class="ghost-button" type="button" id="service-graph-close">{{ t("Close") }}</button>
          </div>
        </header>
        <div class="service-graph-status-row">
          <p class="note service-graph-status" id="service-graph-status">
            {{ t("Press Show graph to load service graph.") }}
          </p>
          <label class="service-graph-toggle" for="service-graph-show-reverse">
            <input id="service-graph-show-reverse" type="checkbox" checked />
            <span>{{ t("Show reverse links") }}</span>
          </label>
        </div>
        <div class="service-graph-canvas" id="service-graph-canvas"></div>
      </section>
    </div>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script>
      (() => {
        const openButton = document.getElementById("render-service-graph");
        const modal = document.getElementById("service-graph-modal");
        const closeButton = document.getElementById("service-graph-close");
        const fitButton = document.getElementById("service-graph-fit");
        const backdrop = document.getElementById("service-graph-backdrop");
        const canvas = document.getElementById("service-graph-canvas");
        const status = document.getElementById("service-graph-status");
        const showReverseToggle = document.getElementById("service-graph-show-reverse");
        const graphApiUrl = {{ block_graph_api_url | tojson }};
        const textLoading = {{ t("Loading graph...") | tojson }};
        const textLoadFailed = {{ t("Failed to load graph data.") | tojson }};
        const textLibraryFailed = {{ t("Graph library did not load. Refresh the page and retry.") | tojson }};
        const textEmpty = {{ t("No block graph data available for this service.") | tojson }};
        const textRendered = {{ t("Rendered {nodes} nodes and {edges} edges.") | tojson }};
        const textErrorPrefix = {{ t("Reason") | tojson }};
        const textProcedure = {{ t("Procedure") | tojson }};
        const textBlock = {{ t("Block") | tojson }};
        const textNestingLevel = {{ t("Nesting level") | tojson }};
        const textUnreachable = {{ t("not reachable from start") | tojson }};
        const textBlockType = {{ t("Block type") | tojson }};
        const textBlockTypeStart = {{ t("start") | tojson }};
        const textBlockTypeRegular = {{ t("regular") | tojson }};
        const blockLinkPathTemplate = {{ settings.catalog.block_link_path | default("", true) | tojson }};

        if (!openButton || !modal || !canvas || !status || !showReverseToggle) {
          return;
        }

        const procedurePalette = [
          "#1b4965",
          "#2a6f97",
          "#5fa8d3",
          "#62b6cb",
          "#90be6d",
          "#f4a261",
          "#e76f51",
          "#a06cd5",
        ];

        let network = null;
        let cachedGraph = null;
        let nodePayloadById = new Map();

        const normalizeTemplate = (template) =>
          String(template || "")
            .trim()
            .replace(/%7B/gi, "{")
            .replace(/%7D/gi, "}");

        const templateFields = (template) => {
          const fields = [];
          const seen = new Set();
          const matcher = /\{([^{}]+)\}/g;
          for (const match of template.matchAll(matcher)) {
            const field = String(match[1] || "").trim();
            if (!field || seen.has(field)) {
              continue;
            }
            seen.add(field);
            fields.push(field);
          }
          return fields;
        };

        const formatTemplate = (template, values) => {
          const normalized = normalizeTemplate(template);
          if (!normalized) {
            return null;
          }
          const fields = templateFields(normalized);
          if (!fields.length) {
            return normalized;
          }
          let formatted = normalized;
          for (const field of fields) {
            const value = values[field];
            if (typeof value !== "string" || !value) {
              return null;
            }
            formatted = formatted.split(`{${field}}`).join(value);
          }
          return formatted;
        };

        const buildBlockLink = (nodePayload) => {
          const blockId = String(nodePayload?.block_id || "").trim();
          if (!blockId) {
            return null;
          }
          const procedureId = String(
            nodePayload?.source_procedure_id || nodePayload?.procedure_id || "",
          ).trim();
          return formatTemplate(blockLinkPathTemplate, {
            block_id: blockId,
            procedure_id: procedureId,
          });
        };

        const setStatus = (message, isError = false) => {
          status.textContent = message;
          status.classList.toggle("is-error", isError);
        };

        const formatRendered = (nodesCount, edgesCount) =>
          textRendered
            .replace("{nodes}", String(nodesCount))
            .replace("{edges}", String(edgesCount));

        const hashProcedure = (procedureId) => {
          let hash = 0;
          for (let idx = 0; idx < procedureId.length; idx += 1) {
            hash = (hash * 33 + procedureId.charCodeAt(idx)) >>> 0;
          }
          return hash % procedurePalette.length;
        };

        const nodeColor = (procedureId) => procedurePalette[hashProcedure(procedureId)];
        const endTypeColors = {
          end: "#8fdc8f",
          exit: "#ffe08a",
          all: "#ffb347",
          intermediate: "#ffb347",
          postpone: "#d9d9d9",
          turn_out: "#cfe3ff",
        };

        const buildDepthMap = (rawNodes, rawEdges) => {
          const adjacency = new Map();
          const inDegree = new Map();
          const initialByNode = new Map();
          rawNodes.forEach((node) => {
            const nodeId = String(node.id);
            adjacency.set(nodeId, []);
            inDegree.set(nodeId, 0);
            initialByNode.set(nodeId, node.is_initial === true);
          });
          rawEdges.forEach((edge) => {
            const source = String(edge.source);
            const target = String(edge.target);
            if (!adjacency.has(source) || !adjacency.has(target)) {
              return;
            }
            adjacency.get(source).push(target);
            inDegree.set(target, (inDegree.get(target) || 0) + 1);
          });

          const startNodes = [];
          inDegree.forEach((value, key) => {
            if (value === 0 && initialByNode.get(key) === true) {
              startNodes.push(key);
            }
          });
          if (!startNodes.length) {
            inDegree.forEach((value, key) => {
              if (value === 0) {
                startNodes.push(key);
              }
            });
          }
          if (!startNodes.length) {
            initialByNode.forEach((isInitial, key) => {
              if (isInitial) {
                startNodes.push(key);
              }
            });
          }

          const depthByNode = new Map();
          const queue = [];
          startNodes.forEach((nodeId) => {
            depthByNode.set(nodeId, 0);
            queue.push(nodeId);
          });

          while (queue.length) {
            const current = queue.shift();
            const baseDepth = depthByNode.get(current);
            if (typeof baseDepth !== "number") {
              continue;
            }
            const nextNodes = adjacency.get(current) || [];
            nextNodes.forEach((nextId) => {
              const nextDepth = baseDepth + 1;
              const seenDepth = depthByNode.get(nextId);
              if (typeof seenDepth !== "number" || nextDepth < seenDepth) {
                depthByNode.set(nextId, nextDepth);
                queue.push(nextId);
              }
            });
          }
          return depthByNode;
        };

        const isReverseEdge = (edge) => String(edge.edge_type || "").endsWith("_cycle");
        const isCycleEdge = (edge) => edge.is_cycle === true || isReverseEdge(edge);

        const closeModal = () => {
          modal.hidden = true;
          document.body.classList.remove("service-graph-open");
        };

        const openModal = () => {
          modal.hidden = false;
          document.body.classList.add("service-graph-open");
        };

        const renderGraph = (graphPayload) => {
          const visLib = window.vis;
          if (
            !visLib ||
            typeof visLib.Network !== "function" ||
            typeof visLib.DataSet !== "function"
          ) {
            setStatus(textLibraryFailed, true);
            return;
          }

          const rawNodes = Array.isArray(graphPayload?.nodes) ? graphPayload.nodes : [];
          const rawEdges = Array.isArray(graphPayload?.edges) ? graphPayload.edges : [];
          if (!rawNodes.length) {
            nodePayloadById = new Map();
            canvas.innerHTML = "";
            setStatus(textEmpty, false);
            return;
          }
          nodePayloadById = new Map(rawNodes.map((node) => [String(node.id), node]));

          const decoratedEdges = rawEdges.map((edge) => ({
            ...edge,
            __isReverse: isReverseEdge(edge),
          }));
          const visibleEdges = showReverseToggle.checked
            ? decoratedEdges
            : decoratedEdges.filter((edge) => edge.__isReverse !== true);
          const depthByNode = buildDepthMap(
            rawNodes,
            visibleEdges,
          );

          const nodes = rawNodes.map((node) => {
            const procedureId = String(node.procedure_id || "");
            const isInitial = node.is_initial === true;
            const endType = String(node.end_block_type || "");
            const roleColor = endTypeColors[endType];
            const background = isInitial ? "#d1ffd6" : roleColor || nodeColor(procedureId);
            const border = isInitial ? "#55a66b" : roleColor ? "#fff7d1" : "#d7e2f3";
            const nodeDepth = depthByNode.get(String(node.id));
            const depthLabel =
              typeof nodeDepth === "number" ? String(nodeDepth) : textUnreachable;
            const blockType = isInitial ? textBlockTypeStart : endType || textBlockTypeRegular;
            return {
              id: String(node.id),
              label: String(node.label || node.block_id || node.id),
              title: `${textProcedure}: ${procedureId}\n${textBlock}: ${String(node.block_id || "")}\n${textBlockType}: ${blockType}\n${textNestingLevel}: ${depthLabel}`,
              shape: "box",
              margin: 8,
              borderWidth: isInitial ? 2 : 1,
              font: {
                color: roleColor || isInitial ? "#1e293b" : "#f8fafc",
                face: "IBM Plex Sans",
                size: 14,
              },
              color: {
                background,
                border,
                highlight: {
                  background,
                  border: "#ffffff",
                },
              },
            };
          });
          const edges = visibleEdges.map((edge) => {
            const edgeType = String(edge.edge_type || "");
            const isCycle = isCycleEdge(edge);
            const isReverse = edge.__isReverse === true;
            return {
              id: String(edge.id || `${edge.source}-${edge.target}-${edgeType}`),
              from: String(edge.source),
              to: String(edge.target),
              arrows: "to",
              dashes: isCycle || isReverse,
              width: isCycle || isReverse ? 2 : 1.5,
              smooth: {
                enabled: true,
                type: "dynamic",
              },
              color: {
                color: isCycle || isReverse ? "#ff7b7b" : "#9fc5ff",
                highlight: isCycle || isReverse ? "#ff9e9e" : "#cfe0ff",
              },
            };
          });

          if (network && typeof network.destroy === "function") {
            network.destroy();
          }
          canvas.innerHTML = "";
          network = new visLib.Network(
            canvas,
            { nodes: new visLib.DataSet(nodes), edges: new visLib.DataSet(edges) },
            {
              autoResize: true,
              layout: { improvedLayout: true },
              interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true,
                hover: true,
              },
              physics: {
                enabled: true,
                stabilization: { iterations: 150 },
              },
            },
          );
          if (typeof network.on === "function") {
            network.on("doubleClick", (params) => {
              const rawNodeId = Array.isArray(params?.nodes) ? params.nodes[0] : null;
              if (rawNodeId === null || rawNodeId === undefined) {
                return;
              }
              const nodeId = String(rawNodeId).trim();
              if (!nodeId) {
                return;
              }
              const nodePayload = nodePayloadById.get(nodeId);
              const blockLink = buildBlockLink(nodePayload);
              if (blockLink) {
                window.location.assign(blockLink);
              }
            });
          }
          if (typeof network.once === "function") {
            network.once("stabilizationIterationsDone", () => {
              if (typeof network.fit === "function") {
                network.fit({ animation: false });
              }
            });
          }
          window.__serviceGraphLastRender = {
            nodes: nodes.length,
            edges: edges.length,
          };
          setStatus(formatRendered(nodes.length, edges.length), false);
        };

        const loadAndRenderGraph = async () => {
          if (cachedGraph) {
            renderGraph(cachedGraph);
            return;
          }
          setStatus(textLoading, false);
          openButton.disabled = true;
          try {
            const response = await fetch(graphApiUrl, {
              credentials: "same-origin",
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache",
              },
            });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            cachedGraph = await response.json();
            renderGraph(cachedGraph);
          } catch (error) {
            const details = error instanceof Error ? error.message : String(error);
            setStatus(`${textLoadFailed} ${textErrorPrefix}: ${details}`, true);
          } finally {
            openButton.disabled = false;
          }
        };

        openButton.addEventListener("click", () => {
          openModal();
          loadAndRenderGraph();
        });
        showReverseToggle.addEventListener("change", () => {
          if (cachedGraph) {
            renderGraph(cachedGraph);
          }
        });
        closeButton?.addEventListener("click", closeModal);
        fitButton?.addEventListener("click", () => {
          if (network && typeof network.fit === "function") {
            network.fit({ animation: true });
          }
        });
        backdrop?.addEventListener("click", closeModal);
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && !modal.hidden) {
            closeModal();
          }
        });
      })();
    </script>
  {% endif %}
  {% if procedure_graph_enabled %}
    <div class="service-graph-modal" id="procedure-graph-modal" hidden>
      <div class="service-graph-backdrop" id="procedure-graph-backdrop"></div>
      <section
        class="service-graph-sheet"
        role="dialog"
        aria-modal="true"
        aria-label="{{ t("Procedure-level diagram") }}"
      >
        <header class="service-graph-toolbar">
          <h3 class="service-graph-title">{{ t("Procedure-level diagram") }}</h3>
          <div class="button-row service-graph-actions">
            <button class="ghost-button" type="button" id="procedure-graph-fit">{{ t("Fit graph") }}</button>
            <button class="ghost-button" type="button" id="procedure-graph-close">{{ t("Close") }}</button>
          </div>
        </header>
        <div class="service-graph-status-row">
          <p class="note service-graph-status" id="procedure-graph-status">
            {{ t("Press Show graph to load procedure graph.") }}
          </p>
          <label class="service-graph-toggle" for="procedure-graph-show-reverse">
            <input id="procedure-graph-show-reverse" type="checkbox" checked />
            <span>{{ t("Show reverse links") }}</span>
          </label>
        </div>
        <div class="service-graph-canvas" id="procedure-graph-canvas"></div>
      </section>
    </div>
    {% if not block_graph_enabled %}
      <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    {% endif %}
    <script>
      (() => {
        const openButton = document.getElementById("render-procedure-graph");
        const modal = document.getElementById("procedure-graph-modal");
        const closeButton = document.getElementById("procedure-graph-close");
        const fitButton = document.getElementById("procedure-graph-fit");
        const backdrop = document.getElementById("procedure-graph-backdrop");
        const canvas = document.getElementById("procedure-graph-canvas");
        const status = document.getElementById("procedure-graph-status");
        const showReverseToggle = document.getElementById("procedure-graph-show-reverse");
        const graphApiUrl = {{ procedure_graph_api_url | tojson }};
        const textLoading = {{ t("Loading graph...") | tojson }};
        const textLoadFailed = {{ t("Failed to load graph data.") | tojson }};
        const textLibraryFailed = {{ t("Graph library did not load. Refresh the page and retry.") | tojson }};
        const textEmpty = {{ t("No procedure graph data available for this service.") | tojson }};
        const textRendered = {{ t("Rendered {nodes} nodes and {edges} edges.") | tojson }};
        const textErrorPrefix = {{ t("Reason") | tojson }};
        const textProcedure = {{ t("Procedure") | tojson }};
        const textPotentialMergeNode = {{ t("Potential merge node") | tojson }};
        const textStarts = {{ t("Starts") | tojson }};
        const textBranches = {{ t("Branches") | tojson }};
        const textEndBlocks = {{ t("End blocks") | tojson }};
        const textNone = {{ t("none") | tojson }};
        const textYes = {{ t("yes") | tojson }};
        const textNo = {{ t("no") | tojson }};
        const procedureLinkPathTemplate = {{ settings.catalog.procedure_link_path | default("", true) | tojson }};

        if (!openButton || !modal || !canvas || !status || !showReverseToggle) {
          return;
        }

        const teamPalette = [
          "#1b4965",
          "#2a6f97",
          "#5fa8d3",
          "#62b6cb",
          "#90be6d",
          "#f4a261",
          "#e76f51",
          "#a06cd5",
        ];

        let network = null;
        let cachedGraph = null;
        let nodePayloadById = new Map();

        const normalizeTemplate = (template) =>
          String(template || "")
            .trim()
            .replace(/%7B/gi, "{")
            .replace(/%7D/gi, "}");

        const templateFields = (template) => {
          const fields = [];
          const seen = new Set();
          const matcher = /\{([^{}]+)\}/g;
          for (const match of template.matchAll(matcher)) {
            const field = String(match[1] || "").trim();
            if (!field || seen.has(field)) {
              continue;
            }
            seen.add(field);
            fields.push(field);
          }
          return fields;
        };

        const formatTemplate = (template, values) => {
          const normalized = normalizeTemplate(template);
          if (!normalized) {
            return null;
          }
          const fields = templateFields(normalized);
          if (!fields.length) {
            return normalized;
          }
          let formatted = normalized;
          for (const field of fields) {
            const value = values[field];
            if (typeof value !== "string" || !value) {
              return null;
            }
            formatted = formatted.split(`{${field}}`).join(value);
          }
          return formatted;
        };

        const buildProcedureLink = (nodePayload) => {
          const procedureId = String(
            nodePayload?.source_procedure_id || nodePayload?.procedure_id || "",
          ).trim();
          if (!procedureId) {
            return null;
          }
          return formatTemplate(procedureLinkPathTemplate, {
            procedure_id: procedureId,
          });
        };

        const setStatus = (message, isError = false) => {
          status.textContent = message;
          status.classList.toggle("is-error", isError);
        };

        const formatRendered = (nodesCount, edgesCount) =>
          textRendered
            .replace("{nodes}", String(nodesCount))
            .replace("{edges}", String(edgesCount));

        const hashText = (value) => {
          let hash = 0;
          for (let idx = 0; idx < value.length; idx += 1) {
            hash = (hash * 33 + value.charCodeAt(idx)) >>> 0;
          }
          return hash % teamPalette.length;
        };

        const nodeColor = (teamName, serviceName) => {
          const key = `${teamName}::${serviceName}`;
          return teamPalette[hashText(key)];
        };

        const closeModal = () => {
          modal.hidden = true;
          document.body.classList.remove("service-graph-open");
        };

        const openModal = () => {
          modal.hidden = false;
          document.body.classList.add("service-graph-open");
        };

        const isReverseEdge = (edge) => String(edge.edge_type || "").endsWith("_cycle");

        const formatEndTypeCounts = (counts) => {
          if (!counts || typeof counts !== "object") {
            return textNone;
          }
          const parts = Object.entries(counts)
            .filter(([, count]) => Number.isFinite(Number(count)) && Number(count) > 0)
            .sort(([left], [right]) => String(left).localeCompare(String(right)))
            .map(([endType, count]) => `${String(endType)}=${Number(count)}`);
          return parts.length ? parts.join(", ") : textNone;
        };

        const renderGraph = (graphPayload) => {
          const visLib = window.vis;
          if (
            !visLib ||
            typeof visLib.Network !== "function" ||
            typeof visLib.DataSet !== "function"
          ) {
            setStatus(textLibraryFailed, true);
            return;
          }
          const rawNodes = Array.isArray(graphPayload?.nodes) ? graphPayload.nodes : [];
          const rawEdges = Array.isArray(graphPayload?.edges) ? graphPayload.edges : [];
          if (!rawNodes.length) {
            nodePayloadById = new Map();
            canvas.innerHTML = "";
            setStatus(textEmpty, false);
            return;
          }
          nodePayloadById = new Map(rawNodes.map((node) => [String(node.id), node]));
          const decoratedEdges = rawEdges.map((edge) => ({
            ...edge,
            __isReverse: isReverseEdge(edge),
          }));
          const visibleEdges = showReverseToggle.checked
            ? decoratedEdges
            : decoratedEdges.filter((edge) => edge.__isReverse !== true);

          const nodes = rawNodes.map((node) => {
            const procedureId = String(node.procedure_id || node.id || "");
            const teamName = String(node.team_name || "");
            const serviceName = String(node.service_name || "");
            const isMergeNode = node.is_merge_node === true;
            const starts = Number(node.start_count || 0);
            const branches = Number(node.branch_count || 0);
            const background = isMergeNode ? "#ffd6d6" : nodeColor(teamName, serviceName);
            return {
              id: String(node.id),
              label: String(node.label || procedureId),
              title:
                `${textProcedure}: ${procedureId}\n` +
                `${textPotentialMergeNode}: ${isMergeNode ? textYes : textNo}\n` +
                `${textStarts}: ${starts}\n` +
                `${textBranches}: ${branches}\n` +
                `${textEndBlocks}: ${formatEndTypeCounts(node.end_type_counts)}`,
              shape: "box",
              margin: 8,
              borderWidth: isMergeNode ? 2 : 1,
              font: {
                color: isMergeNode ? "#1e293b" : "#f8fafc",
                face: "IBM Plex Sans",
                size: 14,
              },
              color: {
                background,
                border: isMergeNode ? "#ffdede" : "#d7e2f3",
                highlight: {
                  background,
                  border: "#ffffff",
                },
              },
            };
          });

          const edges = visibleEdges.map((edge) => {
            const isCycle = edge.is_cycle === true;
            return {
              id: String(edge.id || `${edge.source}-${edge.target}`),
              from: String(edge.source),
              to: String(edge.target),
              arrows: "to",
              dashes: isCycle,
              width: isCycle ? 2 : 1.5,
              smooth: {
                enabled: true,
                type: "dynamic",
              },
              color: {
                color: isCycle ? "#ff7b7b" : "#9fc5ff",
                highlight: isCycle ? "#ff9e9e" : "#cfe0ff",
              },
            };
          });

          if (network && typeof network.destroy === "function") {
            network.destroy();
          }
          canvas.innerHTML = "";
          network = new visLib.Network(
            canvas,
            { nodes: new visLib.DataSet(nodes), edges: new visLib.DataSet(edges) },
            {
              autoResize: true,
              layout: { improvedLayout: true },
              interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true,
                hover: true,
              },
              physics: {
                enabled: true,
                stabilization: { iterations: 150 },
              },
            },
          );
          if (typeof network.on === "function") {
            network.on("doubleClick", (params) => {
              const rawNodeId = Array.isArray(params?.nodes) ? params.nodes[0] : null;
              if (rawNodeId === null || rawNodeId === undefined) {
                return;
              }
              const nodeId = String(rawNodeId).trim();
              if (!nodeId) {
                return;
              }
              const nodePayload = nodePayloadById.get(nodeId);
              const procedureLink = buildProcedureLink(nodePayload);
              if (procedureLink) {
                window.location.assign(procedureLink);
              }
            });
          }
          if (typeof network.once === "function") {
            network.once("stabilizationIterationsDone", () => {
              if (typeof network.fit === "function") {
                network.fit({ animation: false });
              }
            });
          }
          window.__procedureGraphLastRender = {
            nodes: nodes.length,
            edges: edges.length,
          };
          setStatus(formatRendered(nodes.length, edges.length), false);
        };

        const loadAndRenderGraph = async () => {
          if (cachedGraph) {
            renderGraph(cachedGraph);
            return;
          }
          setStatus(textLoading, false);
          openButton.disabled = true;
          try {
            const response = await fetch(graphApiUrl, {
              credentials: "same-origin",
              cache: "no-store",
              headers: {
                "Cache-Control": "no-cache",
              },
            });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            cachedGraph = await response.json();
            renderGraph(cachedGraph);
          } catch (error) {
            const details = error instanceof Error ? error.message : String(error);
            setStatus(`${textLoadFailed} ${textErrorPrefix}: ${details}`, true);
          } finally {
            openButton.disabled = false;
          }
        };

        openButton.addEventListener("click", () => {
          openModal();
          loadAndRenderGraph();
        });
        showReverseToggle.addEventListener("change", () => {
          if (cachedGraph) {
            renderGraph(cachedGraph);
          }
        });
        closeButton?.addEventListener("click", closeModal);
        fitButton?.addEventListener("click", () => {
          if (network && typeof network.fit === "function") {
            network.fit({ animation: true });
          }
        });
        backdrop?.addEventListener("click", closeModal);
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && !modal.hidden) {
            closeModal();
          }
        });
      })();
    </script>
  {% endif %}

  <section class="detail-card markup-info-card">
    <h3>{{ t("Markup information") }}</h3>
    <div class="meta-grid">
      <div class="meta-item">
        <div class="meta-label">{{ t("Markup file") }}</div>
        <div class="meta-value meta-mono">{{ item.markup_rel_path }}</div>
      </div>
      <div class="meta-item">
        <div class="meta-label">{{ "criticality_level" | humanize_text }}</div>
        <div class="meta-value">
          <span class="meta-pill">{{ item.criticality_level | humanize_text }}</span>
        </div>
      </div>
      <div class="meta-item">
        <div class="meta-label">{{ t("Service ID") }}</div>
        <div class="meta-value">
          {% if service_external_url %}
            <a class="meta-link" target="_blank" href="{{ service_external_url }}">
              <span class="meta-link-text">{{ item.finedog_unit_id }}</span>
              <span class="meta-link-icon" aria-hidden="true">↗</span>
            </a>
          {% else %}
            <span class="meta-pill">{{ item.finedog_unit_id }}</span>
          {% endif %}
        </div>
      </div>
      <div class="meta-item">
        <div class="meta-label">{{ t("Team") }}</div>
        <div class="meta-value">
          {% if team_external_url %}
            <a class="meta-link" target="_blank" href="{{ team_external_url }}">
              <span class="meta-link-text meta-team-text">{{ item.team_name }}</span>
              <span class="meta-link-icon" aria-hidden="true">↗</span>
            </a>
          {% else %}
            <span class="meta-pill meta-team-pill">{{ item.team_name }}</span>
          {% endif %}
        </div>
      </div>
    </div>
    {% if item.markup_meta %}
      <div class="meta-grid meta-extra">
        {% for key, value in item.markup_meta.items() %}
          <div>
            <div class="meta-label">{{ key | humanize_text }}</div>
            <div class="meta-value">{{ value }}</div>
          </div>
        {% endfor %}
      </div>
    {% endif %}
  </section>
{% endblock %}
